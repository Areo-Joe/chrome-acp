import type {
  ACPSettings,
  BrowserToolParams,
  BrowserToolResult,
  ConnectionState,
  ContentBlock,
  PermissionRequestPayload,
  PromptCapabilities,
  ProxyMessage,
  ProxyResponse,
  SessionUpdate,
  SessionModelState,
  ModelInfo,
  FileItem,
  FileContent,
  FileChange,
} from "./types";

/**
 * Error thrown when disconnect() is called while a connection is in progress.
 * Callers can use `instanceof` to distinguish this from real connection errors.
 */
export class DisconnectRequestedError extends Error {
  constructor() {
    super("Disconnect requested");
    this.name = "DisconnectRequestedError";
  }
}

export type ConnectionStateHandler = (
  state: ConnectionState,
  error?: string,
) => void;
export type SessionUpdateHandler = (update: SessionUpdate) => void;
export type SessionCreatedHandler = (sessionId: string) => void;
export type PromptCompleteHandler = (stopReason: string) => void;
export type PermissionRequestHandler = (request: PermissionRequestPayload) => void;
export type BrowserToolCallHandler = (
  params: BrowserToolParams,
) => Promise<BrowserToolResult>;
export type ModelChangedHandler = (modelId: string) => void;
export type ModelStateChangedHandler = (state: SessionModelState | null) => void;
export type FileChangesHandler = (changes: FileChange[]) => void;
// Handler for server-pushed directory listings (e.g., after session cwd change)
export type DirListingPushHandler = (path: string, items: FileItem[]) => void;

export class ACPClient {
  private ws: WebSocket | null = null;
  private settings: ACPSettings;
  private connectionState: ConnectionState = "disconnected";
  private sessionId: string | null = null;
  // Reference: Zed's prompt_capabilities in MessageEditor
  // Stores capabilities from agent's initialize response
  private _promptCapabilities: PromptCapabilities | null = null;
  // Reference: Zed stores model state from NewSessionResponse
  private _modelState: SessionModelState | null = null;
  private onModelChanged: ModelChangedHandler | null = null;
  private onModelStateChanged: ModelStateChangedHandler | null = null;

  private onConnectionStateChange: ConnectionStateHandler | null = null;
  private onSessionUpdate: SessionUpdateHandler | null = null;
  private onSessionCreated: SessionCreatedHandler | null = null;
  private onPromptComplete: PromptCompleteHandler | null = null;
  private onPermissionRequest: PermissionRequestHandler | null = null;
  private onBrowserToolCall: BrowserToolCallHandler | null = null;
  private fileChangesHandlers: Set<FileChangesHandler> = new Set();
  private onDirListingPush: DirListingPushHandler | null = null;

  // Pending file operations - keyed by unique requestId to handle concurrent requests
  private requestIdCounter = 0;
  private pendingDirListing: Map<number, { resolve: (items: FileItem[]) => void; reject: (err: Error) => void }> = new Map();
  private pendingFileRead: Map<number, { resolve: (content: FileContent) => void; reject: (err: Error) => void }> = new Map();
  // Track requestId for each path to match responses
  private dirListingRequestIds: Map<string, number> = new Map();
  private fileReadRequestIds: Map<string, number> = new Map();

  private connectResolve: ((value: void) => void) | null = null;
  private connectReject: ((error: Error) => void) | null = null;

  constructor(settings: ACPSettings) {
    this.settings = settings;
  }

  updateSettings(settings: ACPSettings): void {
    this.settings = settings;
  }

  setConnectionStateHandler(handler: ConnectionStateHandler): void {
    this.onConnectionStateChange = handler;
  }

  setSessionUpdateHandler(handler: SessionUpdateHandler): void {
    this.onSessionUpdate = handler;
  }

  setSessionCreatedHandler(handler: SessionCreatedHandler): void {
    this.onSessionCreated = handler;
  }

  setPromptCompleteHandler(handler: PromptCompleteHandler): void {
    this.onPromptComplete = handler;
  }

  setModelChangedHandler(handler: ModelChangedHandler): void {
    this.onModelChanged = handler;
  }

  /**
   * Set handler for model state changes (called when session is created/destroyed).
   * This replaces polling - the handler is called immediately with current state,
   * and again whenever session is created or disconnected.
   */
  setModelStateChangedHandler(handler: ModelStateChangedHandler): void {
    this.onModelStateChanged = handler;
    // Immediately notify with current state
    handler(this._modelState);
  }

  setPermissionRequestHandler(handler: PermissionRequestHandler): void {
    this.onPermissionRequest = handler;
  }

  setBrowserToolCallHandler(handler: BrowserToolCallHandler): void {
    this.onBrowserToolCall = handler;
  }

  /**
   * Set handler for server-pushed directory listings.
   * Called when server sends a dir_listing without a corresponding request
   * (e.g., after session cwd change).
   * Pass null to clear the handler.
   */
  setDirListingPushHandler(handler: DirListingPushHandler | null): void {
    this.onDirListingPush = handler;
  }

  private setState(state: ConnectionState, error?: string): void {
    this.connectionState = state;
    this.onConnectionStateChange?.(state, error);
  }

  getState(): ConnectionState {
    return this.connectionState;
  }

  getSessionId(): string | null {
    return this.sessionId;
  }

  // Reference: Zed's supports_images() in MessageEditor
  // Returns true if the agent supports image content in prompts
  get supportsImages(): boolean {
    return this._promptCapabilities?.image === true;
  }

  // Reference: Zed's prompt_capabilities in MessageEditor
  getPromptCapabilities(): PromptCapabilities | null {
    return this._promptCapabilities;
  }

  /**
   * Get the current model state (available models and current model ID).
   * Reference: Zed's AgentModelSelector reads from state.available_models
   */
  get modelState(): SessionModelState | null {
    return this._modelState;
  }

  /**
   * Check if the agent supports model selection.
   * Reference: Zed's model_selector() returns Option<Rc<dyn AgentModelSelector>>
   */
  get supportsModelSelection(): boolean {
    return this._modelState !== null && this._modelState.availableModels.length > 0;
  }

  async connect(): Promise<void> {
    if (this.ws) {
      this.disconnect();
    }

    this.setState("connecting");

    return new Promise((resolve, reject) => {
      this.connectResolve = resolve;
      this.connectReject = reject;

      try {
        // Build WebSocket URL with token if provided
        let wsUrl = this.settings.proxyUrl;
        if (this.settings.token) {
          const url = new URL(wsUrl);
          url.searchParams.set("token", this.settings.token);
          wsUrl = url.toString();
        }
        const ws = new WebSocket(wsUrl);
        this.ws = ws;

        ws.onopen = () => {
          // Guard against race condition: check if this WebSocket is still current
          if (this.ws !== ws) {
            console.log("[ACPClient] WebSocket opened but already disconnected/replaced, closing stale socket");
            ws.close();
            return;
          }
          console.log("[ACPClient] WebSocket connected, sending connect command");
          this.send({ type: "connect" });
        };

        ws.onmessage = (event) => {
          // Ignore messages from stale sockets
          if (this.ws !== ws) return;
          try {
            const response: ProxyResponse = JSON.parse(event.data);
            this.handleResponse(response);
          } catch (error) {
            console.error("[ACPClient] Failed to parse message:", error);
          }
        };

        ws.onerror = () => {
          // Ignore errors from stale sockets
          if (this.ws !== ws) return;
          console.error("[ACPClient] WebSocket error");
          this.setState("error", "WebSocket connection error");
          this.connectReject?.(new Error("WebSocket connection error"));
          this.connectResolve = null;
          this.connectReject = null;
        };

        ws.onclose = (event) => {
          // Ignore close events from stale sockets (replaced by a new connection)
          if (this.ws !== ws) return;
          console.log("[ACPClient] WebSocket closed", event.code, event.reason);

          // Check if closed due to auth failure (code 4001) or other error during connect
          if (this.connectReject) {
            const errorMessage = event.reason || `Connection closed (code: ${event.code})`;
            this.setState("error", errorMessage);
            this.connectReject(new Error(errorMessage));
            this.connectResolve = null;
            this.connectReject = null;
          } else {
            this.setState("disconnected");
          }

          this.ws = null;
          this.sessionId = null;
        };
      } catch (error) {
        this.setState("error", (error as Error).message);
        reject(error);
      }
    });
  }

  private handleResponse(response: ProxyResponse): void {
    console.log("[ACPClient] Received:", response.type);

    switch (response.type) {
      case "status":
        if (response.payload.connected) {
          this.setState("connected");
          this.connectResolve?.();
        } else {
          this.setState("disconnected");
        }
        this.connectResolve = null;
        this.connectReject = null;
        break;

      case "error":
        console.error("[ACPClient] Error:", response.payload.message);
        this.connectReject?.(new Error(response.payload.message));
        this.connectResolve = null;
        this.connectReject = null;
        break;

      case "session_created":
        this.sessionId = response.payload.sessionId;
        // Reference: Zed stores promptCapabilities from session/initialize response
        this._promptCapabilities = response.payload.promptCapabilities ?? null;
        // Reference: Zed stores model state from NewSessionResponse.models
        this._modelState = response.payload.models ?? null;
        console.log("[ACPClient] Session created, promptCapabilities:", this._promptCapabilities, "models:", this._modelState);
        this.onSessionCreated?.(response.payload.sessionId);
        // Notify model state subscribers (replaces polling in useModels)
        this.onModelStateChanged?.(this._modelState);
        break;

      case "session_update":
        this.onSessionUpdate?.(response.payload.update);
        break;

      case "prompt_complete":
        this.onPromptComplete?.(response.payload.stopReason);
        break;

      case "permission_request":
        console.log("[ACPClient] Permission request:", response.payload);
        this.onPermissionRequest?.(response.payload);
        break;

      case "model_changed":
        console.log("[ACPClient] Model changed:", response.payload.modelId);
        if (this._modelState) {
          this._modelState = {
            ...this._modelState,
            currentModelId: response.payload.modelId,
          };
        }
        this.onModelChanged?.(response.payload.modelId);
        break;

      case "browser_tool_call":
        this.handleBrowserToolCall(response.callId, response.params);
        break;

      case "dir_listing": {
        const requestId = this.dirListingRequestIds.get(response.payload.path);
        if (requestId !== undefined) {
          // Response to a client request
          const pending = this.pendingDirListing.get(requestId);
          if (pending) {
            pending.resolve(response.payload.items);
            this.pendingDirListing.delete(requestId);
          }
          this.dirListingRequestIds.delete(response.payload.path);
        } else {
          // Server-pushed listing (e.g., after session cwd change)
          this.onDirListingPush?.(response.payload.path, response.payload.items);
        }
        break;
      }

      case "file_content": {
        const requestId = this.fileReadRequestIds.get(response.payload.path);
        if (requestId !== undefined) {
          const pending = this.pendingFileRead.get(requestId);
          if (pending) {
            pending.resolve(response.payload);
            this.pendingFileRead.delete(requestId);
          }
          this.fileReadRequestIds.delete(response.payload.path);
        }
        break;
      }

      case "file_changes":
        for (const handler of this.fileChangesHandlers) {
          handler(response.payload.changes);
        }
        break;
    }
  }

  private async handleBrowserToolCall(
    callId: string,
    params: BrowserToolParams,
  ): Promise<void> {
    console.log("[ACPClient] Browser tool call:", callId, params);

    if (!this.onBrowserToolCall) {
      console.error("[ACPClient] No browser tool handler registered");
      this.send({
        type: "browser_tool_result",
        callId,
        result: { error: "No browser tool handler registered" },
      });
      return;
    }

    try {
      const result = await this.onBrowserToolCall(params);
      this.send({
        type: "browser_tool_result",
        callId,
        result,
      });
    } catch (error) {
      console.error("[ACPClient] Browser tool error:", error);
      this.send({
        type: "browser_tool_result",
        callId,
        result: { error: (error as Error).message },
      });
    }
  }

  private send(message: ProxyMessage): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      throw new Error("WebSocket not connected");
    }
    this.ws.send(JSON.stringify(message));
  }

  async createSession(cwd?: string): Promise<void> {
    // Use provided cwd, or fall back to settings.cwd
    const sessionCwd = cwd ?? this.settings.cwd;
    this.send({ type: "new_session", payload: { cwd: sessionCwd } });
  }

  // Reference: Zed's MessageEditor.contents() builds Vec<acp::ContentBlock>
  // and sends via AcpThread.send()
  // Accepts either a string (for backward compatibility) or ContentBlock[]
  async sendPrompt(content: string | ContentBlock[]): Promise<void> {
    if (!this.sessionId) {
      throw new Error("No active session");
    }
    // Convert string to ContentBlock[] for backward compatibility
    const contentBlocks: ContentBlock[] = typeof content === "string"
      ? [{ type: "text", text: content }]
      : content;

    this.send({ type: "prompt", payload: { content: contentBlocks } });
  }

  cancel(): void {
    this.send({ type: "cancel" });
  }

  /**
   * Set the model for the current session.
   * Reference: Zed's AgentModelSelector.select_model() calls connection.set_session_model()
   */
  async setSessionModel(modelId: string): Promise<void> {
    if (!this.sessionId) {
      throw new Error("No active session");
    }
    this.send({ type: "set_session_model", payload: { modelId } });
  }

  respondToPermission(requestId: string, optionId: string | null): void {
    const outcome = optionId
      ? { outcome: "selected" as const, optionId }
      : { outcome: "cancelled" as const };

    this.send({
      type: "permission_response",
      payload: { requestId, outcome },
    });
  }

  // ============================================================================
  // File Explorer Methods
  // ============================================================================

  /**
   * List contents of a directory.
   * @param path - Relative path from agent CWD, empty string for root
   */
  async listDir(path: string): Promise<FileItem[]> {
    const requestId = ++this.requestIdCounter;
    return new Promise((resolve, reject) => {
      this.pendingDirListing.set(requestId, { resolve, reject });
      this.dirListingRequestIds.set(path, requestId);
      try {
        this.send({ type: "list_dir", payload: { path } });
      } catch (err) {
        this.pendingDirListing.delete(requestId);
        this.dirListingRequestIds.delete(path);
        reject(err);
        return;
      }
      // Timeout after 10 seconds
      setTimeout(() => {
        if (this.pendingDirListing.has(requestId)) {
          this.pendingDirListing.delete(requestId);
          this.dirListingRequestIds.delete(path);
          reject(new Error("Directory listing timed out"));
        }
      }, 10000);
    });
  }

  /**
   * Read file content.
   * @param path - Relative path from agent CWD
   */
  async readFile(path: string): Promise<FileContent> {
    const requestId = ++this.requestIdCounter;
    return new Promise((resolve, reject) => {
      this.pendingFileRead.set(requestId, { resolve, reject });
      this.fileReadRequestIds.set(path, requestId);
      try {
        this.send({ type: "read_file", payload: { path } });
      } catch (err) {
        this.pendingFileRead.delete(requestId);
        this.fileReadRequestIds.delete(path);
        reject(err);
        return;
      }
      // Timeout after 10 seconds
      setTimeout(() => {
        if (this.pendingFileRead.has(requestId)) {
          this.pendingFileRead.delete(requestId);
          this.fileReadRequestIds.delete(path);
          reject(new Error("File read timed out"));
        }
      }, 10000);
    });
  }

  /**
   * Subscribe to file change events.
   * @returns Unsubscribe function
   */
  onFileChanges(handler: FileChangesHandler): () => void {
    this.fileChangesHandlers.add(handler);
    return () => {
      this.fileChangesHandlers.delete(handler);
    };
  }

  disconnect(): void {
    // Reject any pending connect promise with a distinguishable error
    // This ensures the promise settles and callers can catch/ignore it
    if (this.connectReject) {
      this.connectReject(new DisconnectRequestedError());
    }
    this.connectResolve = null;
    this.connectReject = null;

    if (this.ws) {
      try {
        this.send({ type: "disconnect" });
      } catch {
        // Ignore send errors during disconnect
      }
      this.ws.close();
      this.ws = null;
    }
    this.setState("disconnected");
    this.sessionId = null;
    this._modelState = null;
    // Notify model state subscribers that session is gone
    this.onModelStateChanged?.(null);

    // Reject all pending file operations before clearing
    const disconnectError = new Error("Disconnected");
    for (const { reject } of this.pendingDirListing.values()) {
      reject(disconnectError);
    }
    for (const { reject } of this.pendingFileRead.values()) {
      reject(disconnectError);
    }
    this.pendingDirListing.clear();
    this.pendingFileRead.clear();
    this.dirListingRequestIds.clear();
    this.fileReadRequestIds.clear();
  }
}

