// Permission option kinds (from ACP protocol)
export type PermissionOptionKind =
  | "allow_once"
  | "allow_always"
  | "reject_once"
  | "reject_always";

// Permission option (from ACP protocol)
export interface PermissionOption {
  optionId: string;
  name: string;
  kind: PermissionOptionKind;
}

// Permission request payload (sent from server to client)
export interface PermissionRequestPayload {
  requestId: string; // Unique ID for this request (generated by server)
  sessionId: string;
  options: PermissionOption[];
  toolCall: {
    toolCallId: string; // Tool call ID to match with existing tool calls
    title?: string;
    content?: ToolCallContent[];
  };
}

// Permission response (sent from client to server)
export interface PermissionResponsePayload {
  requestId: string;
  outcome: { outcome: "cancelled" } | { outcome: "selected"; optionId: string };
}

// ============================================================================
// Browser Tool Types
// ============================================================================
// IMPORTANT: These types MUST stay in sync with packages/proxy-server/src/mcp/types.ts
// They define the protocol between proxy-server and browser extension.
// ============================================================================

export interface BrowserToolParams {
  action: "tabs" | "read" | "execute";
  tabId?: number;   // Required for read/execute
  script?: string;  // Required for execute
}

export interface BrowserTabInfo {
  id: number;
  url: string;
  title: string;
  active: boolean;
}

export interface BrowserTabsResult {
  action: "tabs";
  tabs: BrowserTabInfo[];
}

export interface BrowserReadResult {
  action: "read";
  tabId: number;
  url: string;
  title: string;
  dom: string;
  viewport: {
    width: number;
    height: number;
    scrollX: number;
    scrollY: number;
  };
  selection: string | null;
}

export interface BrowserExecuteResult {
  action: "execute";
  tabId: number;
  url: string;
  result?: unknown;
  error?: string;
}

export type BrowserToolResult =
  | BrowserTabsResult
  | BrowserReadResult
  | BrowserExecuteResult;

// Messages sent TO the proxy server
// Reference: Zed's MessageEditor.contents() builds Vec<acp::ContentBlock>
export type ProxyMessage =
  | { type: "connect" }
  | { type: "disconnect" }
  | { type: "new_session"; payload?: { cwd?: string } }
  | { type: "prompt"; payload: { content: ContentBlock[] } }  // Changed from { text: string } to match Zed
  | { type: "cancel" }
  | { type: "permission_response"; payload: PermissionResponsePayload }
  | { type: "browser_tool_result"; callId: string; result: BrowserToolResult | { error: string } }
  | { type: "set_session_model"; payload: { modelId: string } };

// Messages received FROM the proxy server
export interface ProxyStatusMessage {
  type: "status";
  payload: {
    connected: boolean;
    agentInfo?: { name?: string; version?: string };
    capabilities?: unknown;
  };
}

export interface ProxyErrorMessage {
  type: "error";
  payload: { message: string };
}

// Reference: Zed's session/initialize response includes promptCapabilities and models
export interface ProxySessionCreatedMessage {
  type: "session_created";
  payload: {
    sessionId: string;
    promptCapabilities?: PromptCapabilities;  // From agent's initialize response
    models?: SessionModelState | null;  // Model state if agent supports model selection
  };
}

export interface ProxySessionUpdateMessage {
  type: "session_update";
  payload: {
    sessionId: string;
    update: SessionUpdate;
  };
}

export interface ProxyPromptCompleteMessage {
  type: "prompt_complete";
  payload: { stopReason: string };
}

export interface ProxyPermissionRequestMessage {
  type: "permission_request";
  payload: PermissionRequestPayload;
}

export interface ProxyBrowserToolCallMessage {
  type: "browser_tool_call";
  callId: string;
  params: BrowserToolParams;
}

export interface ProxyModelChangedMessage {
  type: "model_changed";
  payload: {
    modelId: string;
  };
}

export type ProxyResponse =
  | ProxyStatusMessage
  | ProxyErrorMessage
  | ProxySessionCreatedMessage
  | ProxySessionUpdateMessage
  | ProxyPromptCompleteMessage
  | ProxyPermissionRequestMessage
  | ProxyBrowserToolCallMessage
  | ProxyModelChangedMessage;

// Content block types (matches @agentclientprotocol/sdk ContentBlock)
// Reference: Zed's acp::ContentBlock in agent-client-protocol crate
export interface TextContent {
  type: "text";
  text: string;
}

export interface ImageContent {
  type: "image";
  mimeType: string;
  data: string;      // base64 encoded image data
  uri?: string;      // optional URI for the image source
}

export interface ResourceLinkContent {
  type: "resource_link";
  uri: string;
  name: string;
  title?: string;
  description?: string;
  mimeType?: string;
  size?: number;
}

export type ContentBlock = TextContent | ImageContent | ResourceLinkContent | { type: string; text?: string };

// Session update types from ACP
export interface AgentMessageChunkUpdate {
  sessionUpdate: "agent_message_chunk";
  content: ContentBlock;
}

// Tool call content types from ACP
export interface ToolCallContentBlock {
  type: "content";
  content: ContentBlock;
}

export interface ToolCallDiffContent {
  type: "diff";
  path: string;
  oldText?: string | null;
  newText: string;
}

export interface ToolCallTerminalContent {
  type: "terminal";
  terminalId: string;
}

export type ToolCallContent = ToolCallContentBlock | ToolCallDiffContent | ToolCallTerminalContent;

export interface ToolCallUpdate {
  sessionUpdate: "tool_call";
  toolCallId: string;
  title: string;
  status: string;
  content?: ToolCallContent[];
  rawInput?: Record<string, unknown>;
  rawOutput?: Record<string, unknown>;
}

export interface ToolCallStatusUpdate {
  sessionUpdate: "tool_call_update";
  toolCallId: string;
  status?: string;
  title?: string;
  content?: ToolCallContent[];
  rawInput?: Record<string, unknown>;
  rawOutput?: Record<string, unknown>;
}

export interface AgentThoughtChunkUpdate {
  sessionUpdate: "agent_thought_chunk";
  content: ContentBlock;
}

export interface PlanUpdate {
  sessionUpdate: "plan";
}

export interface UserMessageChunkUpdate {
  sessionUpdate: "user_message_chunk";
  content: ContentBlock;
}

export type SessionUpdate =
  | AgentMessageChunkUpdate
  | ToolCallUpdate
  | ToolCallStatusUpdate
  | AgentThoughtChunkUpdate
  | PlanUpdate
  | UserMessageChunkUpdate;

// Connection state
export type ConnectionState =
  | "disconnected"
  | "connecting"
  | "connected"
  | "error";

// PromptCapabilities from ACP protocol
// Reference: Zed's acp::PromptCapabilities in agent-client-protocol crate
// Used to check what content types the agent supports
export interface PromptCapabilities {
  audio?: boolean;           // Agent supports audio content
  embeddedContext?: boolean; // Agent supports embedded context in prompts
  image?: boolean;           // Agent supports image content
}

// ============================================================================
// Model Selection Types (matches @agentclientprotocol/sdk)
// Reference: Zed's AgentModelSelector trait in acp_thread/src/connection.rs
// ============================================================================

/**
 * Information about a selectable model.
 * Matches ACP SDK's ModelInfo type.
 */
export interface ModelInfo {
  /** Unique identifier for the model */
  modelId: string;
  /** Human-readable name of the model */
  name: string;
  /** Optional description of the model */
  description?: string | null;
}

/**
 * The set of models and the one currently active.
 * Matches ACP SDK's SessionModelState type.
 */
export interface SessionModelState {
  /** The set of models that the Agent can use */
  availableModels: ModelInfo[];
  /** The current model the Agent is using */
  currentModelId: string;
}

// Settings
export interface ACPSettings {
  proxyUrl: string;
}

export const DEFAULT_SETTINGS: ACPSettings = {
  proxyUrl: "ws://localhost:9315/ws",
};
